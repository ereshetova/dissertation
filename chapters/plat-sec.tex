\begin{quoting}
\todo[inline]{Find a nice quote here}
\end{quoting}

Nowadays the vast market of mobile and embedded devices grows much faster than a traditional PC or server markets. With many more new use cases implemented and researched, one can speak about an explosion in a number of devices, their security requirements and security models. In order not to get lost in this constantly evolving variety, it is important to define a generic platform security model that can be used for classifying different types of platform security mechanisms and techniques, as well as compare platform security architectures between each other. 

Publication I of this thesis, as well as additional Publication VII (not included in this thesis) based on it, focus on creating this platform security model and comparing existing mobile platform architectures based on it. At the time of writing, mobile platforms were the most prominent direction for the OS platform security research and this explains the focus of the publications. The platform security model, defined in Publication VII is build on top of a set of common design patterns described in Publication I. These include hardware-assisted security mechanisms (secure boot, trusted execution environment, sealing and attestation, etc.) described in Section III, as well as software-only security mechanisms (protection of application integrity, run-time access control and permission assignment etc.), discussed in Section VI. The history of many of these design patterns go back some decades ago and they are constantly reused in newly coming platform security designs as "best known method" to fulfill a certain set of security requirements. For example, the "\textit{measure-before-execute}" design principle that is a foundation of the secure boot mechanism is a robust method to ensure that the software boot chain is free from offline (potentially malicious) modifications. Moreover, the first efforts to define and use hardware-assisted security mechanisms in platform security designs go back to late 1990s when the Trusted Computing Platform Alliance (TCPA)~\cite{pearson2002} defined first hardware-assisted elements for PCs.

There are four different mobile platforms that are discussed in Publication I: Symbian, Java ME, Android and MeeGo and this set is further extended to six in Publication VI by adding iOS and Windows Phone to the comparison. All of these platforms are compared in terms of security mechanisms they support, both hardware-assisted and software-only. However, as history has shown, only two of these mobile platforms have managed to reach significant device volumes in modern days, namely Android and iOS (73.5\% and 19.9\% of mobile market share respectively~\cite{osshare}). \todo[inline]{here tell about Android and iOS changes since} 

However, as we extend our focus to the world of embedded devices, the situation is different: there are no more software platforms or OSes that dominate this market. This is due to a very different nature of how embedded devices are designed and produced by OEMs, as well to a much wider set of use cases that such devices must support, such as automation, automotive, healthcare etc. A typical embedded device is usually a single purpose device, i.e. light sensor, garage door controller, factory supervision drone, but depending on the purpose has very different hardware and software stacks. For example, a device might need to interact with a user and therefore require a user interface or it might not need one at all. Similar with other technology support, as TCP/IP networking, Bluetooth, wireless, etc. 
Thus there is no a single ready-build OS that would serve as a good fit for all of these different purposes without causing an overhead of unnecessary components and instead in the embedded world it is more common to have "\textit{an OS-building set}", such as the ones provided by Open Embedded~\cite{OE2017} or Yocto projects~\cite{yocto2017}. Such sets are usually based on top of mainline Linux OS (both for the OS kernel and for userspace packages) in order to minimize the maintenance cost, because stable mainline Linux projects usually take a good care of keeping their components up-to-date and functioning with the rest of mainline Linux infrastructure, as well as doing various bug fixes and new feature requests. Using such an OS-building set allows even smaller OEMs to deliver their devices fast to the market, which is crucial for their business model. 

When it comes to security, the above trend means that the platform security architectures for embedded devices are mostly composed out of mainline Linux kernel security mechanisms that are used as building blocks to satisfy the set of security requirements for a concrete device. Some bigger OEMs might extend these mechanisms by adding their own private solutions, but it is not common due to high price of maintaining such solutions outside of the rapidly changing mainline Linux kernel source code tree. Following the model presented in Publication VI Figure~\ref{fig:platsec} shows the platform security architecture model that is applicable for any device that would only use the mainline Linux kernel components and optionally might have the security HW support. This is currently more common for rather powerful and advanced devices, but as the cost of including the security HW in the platform would drop with the time, we might see more and more middle-range devices having such features\todo[inline]{need some reference on the trend here}. 

%Similar to the mobile platform security architectures, one can identify a set of well-known design patterns that these different mechanisms follow.


\begin{figure}[t]
	\centering
		\includegraphics[width=1\textwidth]{figures/LinuxKernelPlatSecModel.png}
	\caption{Platform Security Model for an Embedded device based on mainline Linux}
	\label{fig:platsec}
\end{figure}

If present, the \textit{Security HW} layer can be implemented using many existing technologies, such as Trusted Platform Module (TPM)~\cite{tpm}, ARM TrustZone~\cite{trustzone}, etc. In order to communicate with this layer, one needs to provide a \textit{Security HW API}, which is usually done in the form of a custom Linux driver. For example, the mainline Linux kernel has a TPM driver~\cite{tpmdriver} that provides an API to perform various operations supported by TPM Security HW. Regardless of the particular implementation details, there is a set of common elements that any typical Security HW provides:

\begin{itemize}
	\item \textit{Root of Trust}. \textit{Secure boot} is used to guarantee that the device configuration (firmware and software) hasn't been altered from its original trusted state even when device is in offline state. This is typically done by measuring (usually using a hash function) each component of the device firmware and software stack and comparing the measures to the signed reference values. Should the comparison fail, the boot can be either aborted (true "secure boot") or continued but with some measures taken to protect the secrets residing inside Security HW ("authenticated boot"). However, in order for this system to work, one needs to start the measuring chain from an immutable \textit{Root of Trust} that is safely stored inside the Security HW layer. Alternatively, it is possible to implement the secure boot without the support of the security HW, like it is done in the \textit{UEFI Secure boot} mechanism~\cite{uefi}. In this case, the root of trust is embedded directly into the device firmware image. 
	\item \textit{Isolated execution} is another important element of the Security HW that is used to execute the security-critical code that should not be observable in any way by potentially malicious OS or applications. This element is also commonly refereed as \textit{Trusted Execution Environment} (TEE).
	\item \textit{Secure Storage} functionality can be used by different OS components in order to guarantee data integrity and confidentiality even in presence of offline attacks. For example, if TPM module is present on a device, the Integrity Measurement Architecture (IMA) component~\cite{ima}, described below in more details, uses TPM's secure storage functionality to guarantee security of its \textit{trusted keys}.
	\item \textit{Device identification and authentication}. Embedded devices might need to have unique identifiers that can be used for different purposes, such as immutable MAC addresses, automotive identifiers, etc.  Additionally it should be possible for a device to reliably prove its identity to an external party that is typically done in form of a process called "remote attestation". For example this might be needed in order to get access to some external services or to receive platform updates.
	\item \textit{HW Crypto Accelerators} can be used in order to significantly speed up the costly cryptographic computations and in Linux is accessible via dedicated \textit{HW Crypto drivers}, such as TrustZone CryptoCell~\cite{cryptocell} or Intel Quick Assist Technology~\cite{intelQAT} crypto drivers.
\end{itemize}

The mainline Linux kernel itself has a number of platform security mechanisms that aimed at addressing different security requirements. The biggest group of such mechanisms aims to provide methods for implementing \textit{process and application isolation} on a device by means of run-time access control. These mechanisms differ greatly in the level and type of access control they provide depending not only on mechanism itself, but also on associated policy or configuration:

\begin{itemize}
	\item \textit{POSIX capabilities}~\cite{caps} is one of the oldest and easiest to understand: it defines a set (slowly extended through recent decades) of capabilities that can be granted to a process in order to perform a defined system function. For example, a \setype{CAP\_NET\_ADMIN} capability allows a process to perform various privileged network-related operations, like administration of network interfaces and routing tables, access to advanced socket configuration settings, etc. By default the Linux superuser (user id 0:"root") possesses all defined capabilities, while other users have none, but it is possible to create different configurations using file capabilities and capabilities inheriting feature. 
	\item The \textit{Legacy Discretionary Access Control (DAC) mechanism}, initially developed decades ago for separating different device users and their data, is still present and functioning as originally, but since most of the nowadays devices are single-user devices, it can be used for separating processes and group of processes instead. For example, the Android mobile OS uses Linux DAC mechanisms for implementing its permission model. The main downside of DAC is the lack of centralized access control policy that can be enforced device-wise, because each data owner can freely grant access to its data to other processes. 
	\item This gap is addressed by \textit{Mandatory Access Control (MAC)} mechanisms that in the mainline Linux kernel implemented in the form of \textit{Linux Security Modules (LSM)}, such as SELinux, AppArmor, Smack and Tomoyo. They allow defining a unified access control policy for the whole device that can be formally analyzed for allowed information flows, conflicts, etc. MAC LSMs are very powerful access control mechanism in Linux and it is actively used on the systems with strict security requirements for run-time process isolation, such as enterprise servers and mobile devices. 
	\item In addition to MAC LSMs the mainline Linux kernel has additional \textit{special-purpose LSMs} (Yama and Loadpin) that do not provide a system-wide MAC mechanism, but instead serve a much narrower focus of limiting process abilities. For example, Yama LSM allows to limit the dangerous Linux process tracing feature, where a (potentially compromised) process can examine the memory and running state of any other process running under the same user identifier. 
	\item \textit{Seccomp} is another special purpose mechanism that allows a process to restrict the ability to make system calls to a smaller set specified using a seccomp filter. This can be useful if a process performs little system calls after the initialization stage and should it get compromised later on, the compromised process abilities are significantly limited.
\end{itemize} 

Recently two additional mechanisms (initially developed to support OS-level process virtualization) started to be used for application isolation on Linux: \textit{Kernel namespaces} and \textit{cgroups}. These mechanisms, described in more details in Section~\ref{sec:os-virt} of this thesis, allow a process to have its own limited virtualized view of the system to which it is confined and cannot escape from. However, there is a constant debate in the Linux security community on the security level that these mechanisms provide and the appropriate way of using them.   

In addition to mechanisms for process and application isolation, the Linux kernel provides a \textit{Key Management} (\textit{Kernel Keyring}) and \textit{Kernel Crypto API} components. They can be used to generate and store keys and other credentials, and to perform various crypto operations, such as signing, encryption, hashing etc. The set of available algorithms consists from a set implemented within the kernel, as well as additional algorithms that might be provided by Security HW and exposed via \textit{HW Crypto Drivers} described above.

The last remaining mechanism, \textit{Integrity Measurement Architecture} (IMA), and its extension, \textit{Extended Verification Module} (EVM), can be used to extend the secure boot and guarantee the offline integrity of the userspace layer and filesystem. IMA/EVM does this by calculating a hash over each file before it is access and comparing this hash with a reference value stored in file's signed extended attributes. IMA/EVM supports two types of keys: \textit{trusted} and \textit{encrypted}. The former depend on Security HW (such as TPM) being present on the system and stored within its secure storage facilities, while the latter ones can always be used and stored in the Kernel Keyring component. 

Out of all platform security mechanisms described above, the run-time access control methods (required for process and application isolation) are ultimately the hardest to configure and use correctly. Not only the mainline Linux kernel has multiple (and not excluding each other) options, such as traditional UNIX DAC, various MACs, kernel namespaces, POSIX capabilities, seccomp, but each of these options provides unlimited ways of how it can be configured. This is very challenging given that the end security of such mechanisms fully depends on its configuration or a policy, which might be at best provided for some of them only in a reference policy form and only for a certain use case. For example, there is a SELinux reference policy for Fedora desktop that only covers the packages included in the Fedora distribution, but as soon as new packages are added or substituted (common in the case of embedded devices), the policy needs adjustments and additions. Therefore the first main focus of this thesis, described in Chapter~\ref{sec:ac-policies}, is the methods for process isolation and access control, where we will take a look on the typical challenges of building secure MAC policies, as well as propose methods and tools that can help in this process. We will also focus on alternative methods for achieving process and application isolation using OS-level virtualization methods (kernel namespaces). 

In addition to the above described mechanisms, there is an area that recently gained a lot of focus in the mainline Linux security community, namely OS kernel protection against run-time exploits. The importance of this direction cannot be underestimated since a successful attack on the OS kernel itself renders all of its security mechanisms ineffective and useless. Therefore the second main focus of this thesis, described in Chapter~\ref{sec:kernel-hardening}, is OS Kernel Hardening, where we will discuss about overall ways to enhance the run-time exploit protection of the mainline Linux kernel, as well as presenting concrete mechanisms for achieving this goal. 
 