
Nowadays the vast market of mobile and embedded devices is growing much faster than the traditional personal computer (PC) or server markets. With many more new use cases being implemented and researched, one can see an explosion in the number of devices, their security requirements and platform security mechanisms. In order not to get lost in this constantly evolving variety, it is important to define a \textit{generic platform security model} that can be used for classifying different types of security mechanisms and techniques, as well as compare platform security architectures between each other. 

\section{Mobile platform security}

Publication I (which was later expanded to a book~\cite{2013Asokan}) focuses on creating this platform security model and comparing existing mobile platform architectures based on it. At the time of writing, mobile platforms were the most prominent direction for OS platform security research and this explains the focus of the publications. The platform security model, defined in~\cite{2013Asokan}, is built on top of a set of common design patterns described in Publication I. These include hardware-assisted security mechanisms (secure boot, trusted execution environment, sealing and attestation, etc.) described in Section III of Publication I, as well as software-only security mechanisms (protection of application integrity, run-time access control and permission assignment etc.), described in Section VI of Publication I. The history of many of these design patterns go back some decades. They continue to be used in emerging platform security architecture designs. For example, the \textit{measure-before-execute} design principle that is a foundation of the secure boot mechanism is a robust method to ensure that the software boot chain is free from offline (potentially malicious) modifications. Moreover, the first efforts to define and use hardware-assisted security mechanisms in platform security designs go back to late 1990s when the Trusted Computing Platform Alliance (TCPA)~\cite{pearson2002} defined the first hardware-assisted elements for PCs.

There are four different mobile platforms that are discussed in Publication I: Symbian, Java ME, Android and MeeGo. This set is further extended to six in~\cite{2013Asokan} by adding iOS and Windows Phone to the comparison. All of these platforms are compared in terms of security mechanisms they support, both hardware-assisted and software-only. However, as history has shown, only two of these mobile OSes have managed to reach significant device volumes as of now (end 2017), namely Android and iOS (73.5\% and 19.9\% of mobile market share respectively~\cite{osshare}). Both of these platforms preserve their overall platform security models, described in Publications I and~\cite{2013Asokan}, and some valuable new security mechanisms have been added over time, as well as existing ones improved. 

The Android platform saw a major usage growth and strengthening of its mandatory access control (MAC) mechanism, SEAndroid~\cite{smalley12} (a variant of SELinux). Starting from Android 5.0, SEAndroid is mandatory for original equipment manufacturers (OEM) to use and enable in the enforcing mode. The Security Hardware (HW) API, previously limited to the secure storage functionality only, has now been fully changed to an extensive and powerful \textit{Trusty TEE API}~\cite{trusty} that can be used as an interface towards security hardware. Android has also started to support various device encryption methods~\cite{androidencr} in order to guarantee confidentiality of users' data: the full disk encryption and the file-based encryption were added in Android 5.0 and 7.0 releases, respectively. The newly added hardware-backed keystore, Keymaster~\cite{androidkeymaster}, allows applications to take advantage of various cryptographic primitives and have their keys securely stored by underneath. Since Android 7.0, Keymaster also supports \textit{key attestation} and \textit{version binding}, where it is possible to bind keys to a specific version of the OS or even a patch version. 

The iOS platform continues to use the TrustedBSD kernel-provided MAC mechanism for its access control, but the MAC policy has been greatly improved and became more fine-grained~\cite{iOS11}.  Now all applications, including third party ones, can use \textit{entitlements} (iOS term for access control permissions) to request an access to the platform features, such as iCloud, or user information. Applications can be also arranged into groups by its developers for easier data sharing. The encryption and data protection methods have also greatly evolved. Now the offline data protection can be done on a per-file basis by assigning a file to a predefined protection class, such as \textit{Complete Protection} class~\cite{iOS11} that guarantees that a file cannot be decrypted unless users enters the unlock passcode. The same protection classes (albeit with distinct keys) are implemented for the credential items stored in the \textit{Key Chain}. In addition an \textit{Effaceable Storage} feature~\cite{iOS11} guarantees a secure data erasure from the device's persistent storage. 

\section{Embedded platform security}

As we extend our focus from mobile devices to the embedded and Internet of Things (IoT) world, the situation changes: there is no more a single software platform or OS that dominates this market. This is due to the very different nature of how embedded devices are designed and produced by OEMs, as well as to a much wider set of use cases that such devices must support, such as automation, automotive, healthcare etc. A typical embedded device is usually a single purpose device, for example a light sensor, garage door controller or a factory supervision drone, but depending on the purpose can have very different hardware and software stacks. For example, a device might need to interact with a user and therefore require a user interface or it might not need one at all. The same applies to other technology support, such as TCP/IP networking, Bluetooth, wireless, etc. Moreover, embedded devices differ greatly in their hardware capabilities: from very low-end devices having only KB of memory to high-end devices no different from a typical mobile or PC platform.

Thus there is not a single ready-made OS that would serve as a good fit for all of these different purposes without causing an overhead of unnecessary components. Instead, in the embedded world, it is more common to use an \textit{OS-building set}, such as the ones provided by Open Embedded~\cite{OE2017} or Yocto projects~\cite{yocto2017}. Such sets are usually based on the mainline Linux OS (with the exception of very low-end devices that are not capable of running Linux) in order to minimize the maintenance cost, because stable mainline Linux projects usually take good care of keeping their components up-to-date and functioning with the rest of the mainline Linux infrastructure, as well as doing various bug fixes and new feature requests. Using such an OS-building set allows even smaller OEMs to deliver their devices faster to the market, which is crucial for their business model. Thus in this dissertation we focus on the mainline Linux kernel and its components and leave the other smaller footprint OSes, such as Zephyr~\cite{zephyr} and NuttX~\cite{NuttX}, out of the scope. 

When it comes to security, the above trend means that the platform security architectures for embedded devices are mostly composed out of mainline Linux kernel security mechanisms that are used as building blocks to satisfy the set of security requirements for a concrete device. Some bigger OEMs might extend these mechanisms by adding their own private solutions, but it is not common due to the high price of maintaining such solutions outside of the rapidly changing mainline Linux kernel source code tree. Following the model presented in~\cite{2013Asokan}, Figure~\ref{fig:platsec} shows the platform security architecture model that is applicable for any embedded device that would only use the mainline Linux kernel components and might optionally have security hardware support. This is currently more common for rather powerful and advanced devices, but as the cost of including the security hardware in the platform would drop with time, one would see more and more middle-range devices having such features~\cite{marketresearch},~\cite{iothwsecurity}. 


\begin{sidewaysfigure}[ht]
	\centering
		\includegraphics[width=1\textwidth]{figures/LinuxKernelPlatSecModel.png}
	\caption{Platform Security Model for an Embedded device based on mainline Linux}
	\label{fig:platsec}
\end{sidewaysfigure}

\subsection{Security hardware and hardware-assisted mechanisms}

If present, the security hardware layer can be implemented using many existing technologies, such as Trusted Platform Module (TPM)~\cite{tpm}, ARM TrustZone~\cite{trustzone}, etc. In order to communicate with this layer, one needs to provide a \textbf{Security HW API}, which is usually done in the form of a custom Linux driver. For example, the mainline Linux kernel has a TPM driver~\cite{tpmdriver} that provides an API to perform various operations supported by TPM security hardware. Regardless of the particular implementation details, there is a set of common functionality that any typical security hardware provides:

\begin{itemize}
	\item \textbf{Root of trust}. \textit{Secure boot} is used to guarantee that the device configuration (firmware and software) hasn't been altered from its original trusted state even when the device is in the offline state. This is typically done by measuring each component of the device firmware and software stack and comparing the measures to the signed reference values. Should the comparison fail, the boot can be either aborted (true "secure boot") or continued, but with some measures taken to protect the secrets residing inside security hardware (\textit{authenticated boot}). However, in order for this system to work, one needs to start the measuring chain from an immutable root of trust that is safely stored inside the security hardware layer\footnote{If present, the hardware root of trust can be used for many other purposes in addition to the secure boot, such as derivation of keys, secure storage, etc.}. Alternatively, it is possible to implement the secure boot without the support of the security hardware, like is done in the \textit{Unified Extensible Firmware Interface (UEFI) Secure boot} mechanism~\cite{uefi}. In this case, the root of trust is embedded directly into the device firmware image.
	\item \textbf{Isolated execution} is another important functionality that is used to execute security-critical code that should not be observable in any way by potentially malicious OS or applications. This functionality is also commonly referred to as \textit{trusted execution environment} (TEE).
	\item \textbf{Secure storage} functionality can be used by different OS components in order to guarantee data integrity and confidentiality even in the presence of offline attacks. For example, if a TPM module is present on a device, the \textbf{Integrity provider} component (Integrity Measurement Architecture (IMA) in Linux), described below in more detail, uses TPM's secure storage functionality to guarantee security of its \textit{trusted keys}.
	\item \textbf{Device identification and authentication}. Embedded devices might need to have unique identifiers that can be used for different purposes, such as immutable MAC addresses, automotive identifiers, etc.  Additionally it should be possible for a device to reliably prove its local software and/or hardware configuration to an external party, which is typically done in the form of a process called textit{remote attestation}. For example, this might be needed in order to get access to some external services or receive platform updates.
	\item \textbf{Hardware crypto accelerators} can be used in order to significantly speed up the costly cryptographic computations and in Linux are accessible via dedicated \textbf{HW crypto drivers}, such as TrustZone CryptoCell~\cite{cryptocell} or Intel Quick Assist Technology~\cite{intelQAT} cryptographic drivers.
\end{itemize}

The mainline Linux kernel also provides a \textbf{key management} (aka Kernel Keyring~\cite{keyrings}) and \textbf{Kernel Crypto API}~\cite{kernelcryptoapi} components. They can be used to generate and store keys and other credentials, and to perform various cryptographic operations, such as signing, encryption, hashing etc. The set of available algorithms consists of a set implemented within the kernel, as well as additional algorithms that might be provided by security hardware and exposed via \textit{HW Crypto Drivers} described above.

The last remaining mechanism, the \textbf{Integrity provider} component, implemented in Linux by the Integrity Measurement Architecture (IMA)~\cite{ima}, and its extension, Extended Verification Module (EVM)~\cite{ima}, can be used to extend the secure boot and guarantee the offline integrity of the userspace layer and filesystem. IMA/EVM does this by calculating a hash over each file before it is accessed and comparing this hash with a reference value stored in the file's signed extended attributes. IMA/EVM supports two types of keys: \textit{trusted} and \textit{encrypted}. The former depend on security hardware (such as TPM) being present on the system and stored within its secure storage facilities, while the latter ones can always be used and stored in the Kernel Keyring component. 

\subsection{Mechanisms for process isolation and access control}

The mainline Linux kernel itself has a number of platform security mechanisms that aim at addressing different security requirements. The biggest group of such mechanisms provides ways for implementing \textit{process and application isolation} on a device by means of a run-time access control. These mechanisms differ greatly in the level and type of access control they provide, depending not only on the mechanism itself, but also on its associated policy or configuration:

\begin{itemize}
	\item \textbf{POSIX capabilities}~\cite{caps} is a set of permissions that can be granted to a process in order to perform a defined system function. For example, a \setype{CAP\_NET\_ADMIN} capability allows a process to perform various privileged network-related operations, like administration of network interfaces and routing tables, access to advanced socket configuration settings, etc. By default the Linux superuser ("root" user with user id 0) possesses all defined capabilities, while other users have none, but it is possible to create different configurations using the \textit{file capabilities} feature~\cite{filecaps}. 
	\item The \textbf{legacy discretionary access control (DAC)} mechanism, initially developed decades ago for separating different device users and their data, is still present and functioning as originally designed, but since most present-day devices are single-user, it is used instead for separating processes and groups of processes. For example, the Android mobile OS uses Linux DAC mechanisms for implementing its permission model. The main downside of DAC is the lack of a centralized access control policy that can be enforced device-wise, because each data owner can freely grant access to its data to other processes. 
	\item The shortcoming of DAC is addressed by \textbf{mandatory access control (MAC)} mechanisms that in the mainline Linux kernel are implemented in the form of \textit{Linux Security Modules (LSM)}, such as SELinux~\cite{smalley2001implementing}, AppArmor~\cite{bauer2006paranoid}, Smack~\cite{bauer2006paranoid} and Tomoyo~\cite{tomoyo}. They allow defining a unified access control policy for the whole device that can be formally analyzed for allowed information flows, conflicts, etc. MAC LSMs are very powerful access control mechanisms in Linux and are actively used on systems with strict security requirements for run-time process isolation, such as enterprise servers and mobile devices. 
	\item In addition to MAC LSMs, the mainline Linux kernel has \textbf{special-purpose LSMs}, Yama~\cite{yama} and Loadpin~\cite{loadpin}, that do not provide a system-wide MAC mechanism, but instead serve a much narrower focus of limiting process abilities. For example, Yama LSM allows limiting the dangerous Linux process tracing feature, where a (potentially compromised) process can examine the memory and running state of any other process running under the same user identifier. 
	\item \textbf{Seccomp}~\cite{seccomp2016} is another special purpose mechanism that allows a process to restrict the ability to make system calls to a smaller set specified using a seccomp filter. This can be useful if a process performs few system calls after the initialization stage and, should it get compromised later on, the compromised process abilities are significantly limited.
\end{itemize} 

Recently two additional mechanisms, initially developed to support OS-level process virtualization, have started to be used for application isolation on Linux: \textbf{kernel namespaces}~\cite{biederman2006} and \textbf{cgroups}~\cite{cgroupsv2}. These mechanisms, described in more detail in Section~\ref{sec:os-virt} of this dissertation, allow a process to have its own limited virtualized view of the system to which it is confined and cannot escape from. However, there is a constant debate in the Linux security community about the security level that these mechanisms provide and the appropriate way of using them.   

\section{Discussion}

Out of all platform security mechanisms described above, the process and application isolation methods are ultimately the hardest ones to configure and use correctly. Not only does the mainline Linux kernel have multiple options that can be used simultaneously, but each of these options provides unlimited ways of how it can be configured. This is very challenging given that the end security of such mechanisms fully depends on their configuration or policy, which might be at best provided only in a reference policy form and only for certain limited use cases. For example, there is a SELinux reference policy for Fedora desktop that only covers the packages included in the Fedora distribution, but as soon as new packages are added or substituted (common in the case of embedded devices), the policy needs adjustments and additions. 

Therefore the first main focus of the dissertation, described in Chapter~\ref{sec:ac-policies}, is the method for process isolation and access control, where we will take a look at the typical challenges of building secure MAC policies, as well as propose methods and tools that can help in the process. We will also focus on alternative mechanisms for achieving process and application isolation by using OS-level virtualization methods. 

In addition to the mechanisms described above, there is an area that has recently gained a lot of attention in the mainline Linux security community, namely the OS kernel's protection against run-time exploits. The importance of this direction cannot be underestimated since a successful attack on the OS kernel itself renders all of its security mechanisms ineffective and useless. Therefore the second main focus of the dissertation, described in Chapter~\ref{sec:kernel-hardening}, is OS kernel hardening, where we will discuss the overall ways to enhance the run-time exploit protection of the mainline Linux kernel, as well as present concrete mechanisms for achieving this goal. 
 